#!/usr/bin/env python3

import argparse
import os
import json
import re
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Table
from PIL import Image, ImageDraw, ImageFont
import colorsys


def parse_arguments():
    # Initialize a parser for command-line arguments.
    parser = argparse.ArgumentParser(description='Generate PDF or image from color data')
    parser.add_argument('input_json_path', help='path to input JSON file')
    parser.add_argument('output_path', help='path to output file (PDF, PNG, or JPG)')
    return parser.parse_args()


def is_hex_color(value):
    # Check if the input is a string, as hex color should be a string type.
    if isinstance(value, str):
        # Regular expression to match valid hex color:
        # ^#: Ensure that the first character is #
        # (?:...): A non-capturing group
        # [0-9a-fA-F]{3}: Match three hexadecimal characters
        # {1,2}: Repeat the non-capturing group once or twice, matching either a short (3-digit) or long (6-digit) hex color.
        return bool(re.match(r'^#(?:[0-9a-fA-F]{3}){1,2}$', value))
    return False


def extract_hex_colors(data, parent_key=""):
    colors_data = {}
    # Check if the data is a dictionary type.
    if isinstance(data, dict):
        # Iterate through key-value pairs in the dictionary.
        for key, value in data.items():
            # Construct a key with a hierarchy, using '.' as a separator.
            full_key = f"{parent_key}.{key}" if parent_key else key
            if is_hex_color(value):
                # If the value is a hex color, store it.
                colors_data[full_key] = value
            elif isinstance(value, (dict, list)):
                # If the value is a dictionary or list, recursively extract hex colors.
                colors_data.update(extract_hex_colors(value, full_key))
    elif isinstance(data, list):
        # If the data is a list, iterate through its elements.
        for idx, item in enumerate(data):
            # Construct a key using the index within square brackets.
            full_key = f"{parent_key}[{idx}]" if parent_key else f"[{idx}]"
            colors_data.update(extract_hex_colors(item, full_key))
    return colors_data


def load_json_data(input_json_path):
    try:
        # Open and read the JSON file.
        with open(input_json_path) as json_file:
            data = json.load(json_file)
            # Extract hex colors from the loaded JSON data.
            return extract_hex_colors(data)
    except (FileNotFoundError, json.JSONDecodeError, Exception) as e:
        # Handle exceptions related to file not found or JSON decode errors.
        raise Exception("Unable to load JSON data.") from e


def adjust_text_color(bg_color):
    # Extract red, green, and blue components from the hex color.
    r, g, b = colors.HexColor(bg_color).red, colors.HexColor(bg_color).green, colors.HexColor(bg_color).blue
    # Convert RGB to YIQ to get luminance.
    luminance = colorsys.rgb_to_yiq(r, g, b)[0]
    # Return black or white text color based on the background color's luminance.
    return colors.black if luminance > 0.5 else colors.white


def create_color_box_pdf(color_hex, description):
    # Create a PDF table cell with a specified color and description.
    return Table(
        [[description]],  # Content of the table cell.
        colWidths=letter[0], # Width of the column equal to the width of the page.
        rowHeights=50, # Height of the row.
        style=[
            ('BACKGROUND', (0, 0), (-1, -1), colors.HexColor(color_hex)), # Background color.
            ('TEXTCOLOR', (0, 0), (-1, -1), adjust_text_color(color_hex)), # Text color based on the background color.
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'), # Left-aligned text.
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'), # Vertically center the text.
        ],
    )


def generate_pdf(colors_data, filename):
    # Create a PDF document with the specified filename and letter page size.
    doc = SimpleDocTemplate(filename, pagesize=letter)
    # Create elements for the PDF, one for each color entry.
    elements = [create_color_box_pdf(color_hex, f"{color_name}: {color_hex}") for color_name, color_hex in
                colors_data.items()]
    # Build the PDF document with the elements.
    doc.build(elements)


def generate_image(colors_data, filename):
    row_height = 50
    # Define the width and height of the image. <---
    width, height = int(letter[0]), int(row_height * len(colors_data))
    # Create a new white image with the defined size.
    image = Image.new('RGB', (width, height), color="white")
    # Create a drawing context for the image.
    draw = ImageDraw.Draw(image)
    # Load the default font.
    font = ImageFont.load_default()

    y = 0 # Initialize the y-coordinate for drawing.
    for color_name, color_hex in colors_data.items():
        # Construct a description for the color box.
        box_description = f"{color_name}: {color_hex}"
        # Convert the hex color to an RGB tuple.
        hex_color = tuple(int(color_hex.lstrip("#")[i:i + 2], 16) for i in (0, 2, 4))
        # Determine the text color based on the background color.
        text_color = (0, 0, 0) if adjust_text_color(color_hex) == colors.black else (255, 255, 255)
        # Draw a rectangle for the color box.
        draw.rectangle([0, y, width, y + row_height], fill=hex_color)
        # Draw the text description inside the color box.
        draw.text((10, y + row_height // 2 - 10), box_description, font=font, fill=text_color)
        # Increment the y-coordinate for the next row.
        y += row_height

    # Save the image to the specified filename.
    image.save(filename)


def generate_output(colors_data, filename):
    # Extract the file extension from the filename.
    extension = os.path.splitext(filename)[1].lower()

    # Determine the output format based on the extension and generate the corresponding file.
    if extension in ['.pdf']:
        generate_pdf(colors_data, filename)
    elif extension in ['.png', '.jpg', '.jpeg']:
        generate_image(colors_data, filename)
    else:
        print("Unsupported file format. Please use .pdf, .png, .jpg, or .jpeg.")


def main():
    # Parse command-line arguments.
    args = parse_arguments()

    # Get absolute paths for the input and output files.
    input_json_path = os.path.abspath(args.input_json_path)
    output_path = os.path.abspath(args.output_path)

    # Load colors data from the JSON file.
    colors_data = load_json_data(input_json_path)
    if colors_data is not None:
        # Generate the output file (PDF or image) based on the colors data.
        generate_output(colors_data, output_path)
        print("Output generated successfully at:", output_path)


if __name__ == "__main__":
    # If the script is executed directly, run the main function.
    main()
